
#pragma config(Sensor, in1,    catPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl9,  leftQuad,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightQuad,      sensorQuadEncoder)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           pDriveLF,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           pDriveLM,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           pDriveLR,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           catR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           catL,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           pDriveRF,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           pDriveRM,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           pDriveRR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          arm,           tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#define swapNewPress(int button, bool lastInput, bool variable) ( ((vexRT[button]) && (!lastInput)) ? (!variable) : (variable) )
//#define direction(int power) ( (abs(power) / (power) )

void setDrive(int leftSpeed, int rightSpeed) {
	motor[pDriveLF] = motor[pDriveLM] = motor[pDriveLR] = leftSpeed;
	motor[pDriveRF] = motor[pDriveRM] = motor[pDriveRR] = rightSpeed;
}

void setDrive(int speed) {
	setDrive(speed, speed);
}

void setDrive() {
	setDrive(127);
}

void setCatapult(int speed) {
	motor[catR] = motor[catL] = speed;
}

void setCatapult() {
	setCatapult(127);
}

void setIntake(int speed) {
	motor[intake] = speed;
}

void setIntake() {
	setIntake(127);
}

void setArm(int speed) {
	motor[arm] = speed;
}

void setArm() {
	setArm(127);
}

int buttonToPower(int downButton, int upButton, int power) {
	return vexRT[downButton] ? -power : vexRT[upButton] ? power : 0;
}

int buttonToPower(int button, int power) {
	return vexRT[button] ? power : 0;
}

int deadZone(int channel){
	return abs(vexRT[channel]) >= 10 ? vexRT[channel] : 0;
}

bool newPress(int channel, bool lastInput) {
	return lastInput ? false : vexRT[channel];
}

bool lowerCatapult(int position) {
	if (SensorValue[catPot] < position) {
		setCatapult(127);
		return false;
	} else {
		return true;
	}
}

void lockBase(int position) {
	double k = .45;
	setDrive(k*(SensorValue[rightQuad] - position));
}

task main()
{
	bool lastArm = false;
	bool lastBase = false;
	bool dir = false;
	bool catRun = true;
	float turtle = 1;
	bool lockedBase = false;
	int currentLock;

	while (true) {
		turtle = vexRT[Btn5U] ? 0.5 : 1;

		lockedBase = newPress(Btn7U, lastBase) ? !lockedBase : lockedBase;
		lastBase = vexRT[Btn7U];

		if (!lockedBase) {
			setDrive(deadZone(Ch3) * turtle, deadZone(Ch2) * turtle) ;
			currentLock = SensorValue[rightQuad];
		} else {
			lockBase(currentLock);
		}

		dir = newPress(Btn8U, lastArm) ? !dir : dir;
		setArm(buttonToPower(Btn6D, Btn8D, 127*(dir ? 1 : -1)));
		lastArm = vexRT[Btn8U];

		if (catRun) {
			setCatapult(buttonToPower(Btn6U, 127));
			catRun = !vexRT[Btn7R];
		} else {
			catRun = lowerCatapult(3700);
		}

		setIntake(buttonToPower(Btn5D, Btn5U, 127));

		delay(20);
	}
}
